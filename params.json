{"body":"## Introduction\r\n\r\nlibencoding aims to provide a generic and extensible encoding conversion library. It's main component\r\nis the `converter<>` class template which perform the conversion from an input encoding to an output\r\nencoding. It is declare as follow:\r\n\r\n```c++\r\n    template <\r\n        class FromCharT,\r\n        class FromEncoding,\r\n        class ToCharT,\r\n        class ToEncoding\r\n    > struct converter;\r\n```\r\n\r\nInstance of this function object provide an `operator()` that accept an input iterator range\r\n`[first, last)` of character type for the input encoding and an output iterator where character type\r\nfor the output encoding will be placed.\r\n\r\n```c++\r\n    using namespace encoding;\r\n    \r\n    converter<char, utf8, std::uint32_t, utf32> conv;\r\n    \r\n    const char utf8_buffer[] = u8\"Lorem ipsum\";\r\n    std::vector<std::uint32_t> utf32_buffer;\r\n    \r\n    conv(std::begin(utf8_buffer), std::end(utf8_buffer), std::back_inserter(utf32_buffer));\r\n```\r\n\r\nSince the conversion of a string literal is a common task and tedious to write, an overload is\r\nprovide which replace the input iterator range is replace by a `const from_char_type (&)[N]`\r\nparameter. So the above example could have been simply write:\r\n\r\n```c++\r\n    conv(u8\"Lorem ipsum\", std::back_inserter(utf32_buffer));\r\n```\r\n\r\nThe default behaviour is to throw an exception if an error occure or if the operation result in a\r\npartial conversion. For a fine grain error handling, an overload is provide with a `std::error_code&`\r\nparameter where the corresponding error code will be place.\r\n\r\n## Motivation and Scope\r\n\r\nI am working on this library for two main purpose:\r\n- Learning about unicode encoding and libary design.\r\n- Try to get a simple libary that offer many possibilities for modern C++ development.\r\n\r\n### The possibility to add a new encoding easily\r\n\r\n### The possibility to optimize selected conversions\r\n\r\n### The possibility to write generic code independant of the encoding\r\n\r\n### The possibility to use modern and standard practices\r\n\r\n## Design Decisions\r\n\r\n## Technical Specifications\r\n\r\n```c++\r\nnamespace encoding\r\n{\r\n    enum class encoding_errc\r\n    {\r\n        trailing_byte_expected = 1,\r\n        leading_byte_expected,\r\n        partial_conversion,\r\n        ill_formed_code_unit,\r\n        ill_formed_code_point,\r\n        ill_formed_byte_sequence\r\n    };\r\n\r\n    const std::error_category& encoding_category();\r\n\r\n    std::error_code make_error_code(encoding_errc e);\r\n    std::error_code make_error_condition(encoding_errc e);\r\n\r\n    struct utf32   { };\r\n    struct utf32le { };\r\n    struct utf32be { };\r\n    struct utf16   { };\r\n    struct utf16le { };\r\n    struct utf16be { };\r\n    struct utf8    { };\r\n\r\n    template<class Encoding> struct max_code_unit_per_code_point;\r\n\r\n    template<> struct max_code_unit_per_code_point<utf32>;\r\n    template<> struct max_code_unit_per_code_point<utf32le>;\r\n    template<> struct max_code_unit_per_code_point<utf32be>;\r\n    template<> struct max_code_unit_per_code_point<utf16>;\r\n    template<> struct max_code_unit_per_code_point<utf16le>;\r\n    template<> struct max_code_unit_per_code_point<utf16be>;\r\n    template<> struct max_code_unit_per_code_point<utf8>;\r\n\r\n    template<class Encoding> struct min_code_unit_per_code_point;\r\n\r\n    template<> struct min_code_unit_per_code_point<utf32>;\r\n    template<> struct min_code_unit_per_code_point<utf32le>;\r\n    template<> struct min_code_unit_per_code_point<utf32be>;\r\n    template<> struct min_code_unit_per_code_point<utf16>;\r\n    template<> struct min_code_unit_per_code_point<utf16le>;\r\n    template<> struct min_code_unit_per_code_point<utf16be>;\r\n    template<> struct min_code_unit_per_code_point<utf8>;\r\n\r\n    template<class Encoding>\r\n    struct is_variable_length\r\n        : std::integral_constant<bool,\r\n            max_code_unit_per_code_point<Encoding>::value\r\n            != min_code_unit_per_code_point<Encoding>::value\r\n          >\r\n    {\r\n    };\r\n\r\n    template <\r\n        class FromCharT,\r\n        class FromEncoding,\r\n        class ToCharT,\r\n        class ToEncoding\r\n    > struct converter\r\n    {\r\n        typedef FromCharT    from_char_type;\r\n        typedef FromEncoding from_encoding;\r\n        typedef ToCharT      to_char_type;\r\n        typedef ToEncoding   to_encoding;\r\n\r\n        converter() = default;\r\n        converter(const converter&) = default;\r\n        converter(converter&&) = default;\r\n\r\n        ~converter() = default;\r\n\r\n        converter& operator=(const converter&) = default;\r\n        converter& operator=(converter&&) = default;\r\n\r\n        template<class InputIterator, class OutputIterator>\r\n        void operator()(InputIterator first,\r\n                        InputIterator last,\r\n                        OutputIterator out,\r\n                        std::error_code& e);\r\n\r\n        template<class InputIterator, class OutputIterator>\r\n        void operator()(InputIterator first,\r\n                        InputIterator last,\r\n                        OutputIterator out);\r\n\r\n        template<std::size_t N, class OutputIterator>\r\n        void operator()(const from_char_type (&str)[N],\r\n                        OutputIterator out,\r\n                        std::error_code& e);\r\n\r\n        template<std::size_t N, class OutputIterator>\r\n        void operator()(const from_char_type (&str)[N],\r\n                        OutputIterator out);\r\n    };\r\n\r\n    // UTF-32\r\n    template<class FromCharT, class ToCharT> struct converter<FromCharT, utf32,   ToCharT, utf32>;\r\n\r\n    // UTF-32LE\r\n    template<class FromCharT, class ToCharT> struct converter<FromCharT, utf32,   ToCharT, utf32le>;\r\n    template<class FromCharT, class ToCharT> struct converter<FromCharT, utf32le, ToCharT, utf32>;\r\n\r\n    // UTF-32BE\r\n    template<class FromCharT, class ToCharT> struct converter<FromCharT, utf32,   ToCharT, utf32be>;\r\n    template<class FromCharT, class ToCharT> struct converter<FromCharT, utf32be, ToCharT, utf32>;\r\n\r\n    // UTF-16\r\n    template<class FromCharT, class ToCharT> struct converter<FromCharT, utf32,   ToCharT, utf16>;\r\n    template<class FromCharT, class ToCharT> struct converter<FromCharT, utf16,   ToCharT, utf32>;\r\n\r\n    // UTF-16LE\r\n    template<class FromCharT, class ToCharT> struct converter<FromCharT, utf32,   ToCharT, utf16le>;\r\n    template<class FromCharT, class ToCharT> struct converter<FromCharT, utf16le, ToCharT, utf32>;\r\n\r\n    // UTF-16BE\r\n    template<class FromCharT, class ToCharT> struct converter<FromCharT, utf32,   ToCharT, utf16be>;\r\n    template<class FromCharT, class ToCharT> struct converter<FromCharT, utf16be, ToCharT, utf32>;\r\n\r\n    // UTF-8\r\n    template<class FromCharT, class ToCharT> struct converter<FromCharT, utf32,   ToCharT, utf8>;\r\n    template<class FromCharT, class ToCharT> struct converter<FromCharT, utf8,    ToCharT, utf32>;\r\n} // namespace encoding\r\n\r\nnamespace std \r\n{ \r\n    template<> \r\n    struct is_error_code_enum<encoding::encoding_errc> : true_type { }; \r\n} // namespace std\r\n```\r\n\r\n## References\r\n\r\nThe Unicode Consortium. The Unicode Standard.\r\n\r\n[http://www.unicode.org/versions/latest/](http://www.unicode.org/versions/latest/)","tagline":"","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"libencoding","google":""}